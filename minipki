#!/usr/bin/env python3
# -*- mode: python -*-

# minipki
# Author: Micah R Ledbetter
# Acknowledgements: 
# - http://sial.org/howto/openssl/ca/
# - http://www.openssl.org/docs/apps/ca.html

import sys
import os
import shutil
import argparse
import logging
import subprocess
import socket
import re
import configparser
from string import Template

scriptdir = os.path.abspath(os.curdir)
defaultconfigpath = os.path.join(scriptdir, 'config.default')
localconfigpath = os.path.join(scriptdir, 'config.local')
allconfig = configparser.ConfigParser()
allconfig.read([defaultconfigpath, localconfigpath])
config = allconfig['minipki']
#config['rooturl'] = 'http://' + config['url_addr'] + ':' + config['port']

def debugprint(text):
    if config.getboolean('debug'):
        print("DEBUG: " + text)

if config.getboolean('debug'):
    from pdb import set_trace as strace
    logging.basicConfig(level=logging.DEBUG) 
else:
    def strace(): 
        pass

def is_exe(fpath):
    return os.path.exists(fpath) and os.access(fpath, os.X_OK)

def template_from_file(fpath):
    rf = open(os.path.abspath(fpath, 'r'))
    data = rf.read()
    rf.close()
    return Template(data)

def which(program):
    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file
    return None


def initca(self, args):
    if args.purge:
        for p in os.listdir("."): 
            if os.path.isfile(p) or os.path.islink(p): 
                os.unlink(p)
            elif os.path.isdir(p):
                shutil.rmtree(p)
    else: 
        for p in ["serial.txt", "index.txt", "private", "newcerts", 
                  "certified-keys", CA_CNF]:
            if (os.path.exists(p)):
                print("Path '" + p + "' exists, exiting...")
                sys.exit(fcnf)

    1=open(CA_CNF,'w')
    fcnf.write(build_ca_cnf(self,args))
    fcnf.close()

    fserial=open("serial.txt","w")
    fserial.write("01")
    fserial.close()
    open("index.txt","w").close() #create an empty file
    os.mkdir("private",0o700)
    os.mkdir("newcerts",0o700)
    os.mkdir("certified-keys",0o700)

    proc = subprocess.Popen([opensslbin, 
                             "req", #request a new key
                             "-config", CA_CNF,

                             # don't create an encrypted key (& don't prompt 
                             # for enc password): 
                             "-nodes",  

                             # put out a self-signed cert instead of a csr; 
                             # required for a CA
                             "-x509", 
                             "-days", str(CA_VALID_DAYS),

                             #will output to stdout otherwise
                             "-out", "ca.crt.pem", 

                             #create an RSA key store it where cnf says
                             "-newkey", "rsa:"+str(keysize)], 
                            env={"OPENSSL_CONF": CA_CNF})
    proc.wait()

def genprivkey(self, args):
    keyname=args.keyname
    logging.debug("genprivkey args: %r" % args)
    if args.cnf: 
        if not (os.path.exists(args.cnf)):
            print("Server configuration file specified on command line as",
                  "{}, but file does not exist. Exiting...".format(args.cnf))
            sys.exit(1)
        servercnf=args.cnf
    else:
        servercnf="certified-keys/"+keyname+".openssl.cnf"
        if not (os.path.exists(servercnf)):
            logging.debug("genprivkey: openssl configuration file not present,",
                          "generating...")
            makecnf(self,args)

    proc = subprocess.Popen([opensslbin, "genrsa", "-out", 
                             "certified-keys/"+keyname+".key", str(keysize)],
                            env={"OPENSSL_CONF": servercnf})
    proc.wait()

    proc = subprocess.Popen([opensslbin, 
                             "req", 
                             "-new", 
                             "-nodes",
                             "-config", servercnf, 
                             "-key", "certified-keys/"+keyname+".key", 
                             "-out", "certified-keys/"+keyname+".csr"],
                            env={"OPENSSL_CONF": servercnf})
    proc.wait()

def build_ca_cnf(self, args):
    t = template_from_file('openssl.cnf.ca.template')

    emailAddressLine = countryNameLine = stateOrProvinceLine = ""
    localityNameLine = organizationNameLine = ""
    if args.emailAddress:
        emailAddressLine = "emailAddress = " + args.emailAddress
    if args.countryName:
        countryNameLine = "countryName = " + args.countryName
    if args.stateOrProvince:
        stateOrProvinceLine = "stateOrProvince = " + args.stateOrProvince
    if args.localityName:
        localityNameLine = "localityName = " + args.localityName
    if args.organizationName: 
        organizationNameLine = "organizationName = " + args.organizationName

    cacnf = t.substitute(ca_commonName = args.ca_commonName,
                         emailAddressLine = emailAddressLine,
                         countryNameLine = countryNameLine,
                         stateOrProvinceLine = stateOrProvinceLine,
                         localityNameLine = localityNameLine,
                         organizationNameLine = organizationNameLine,
                         default_keysize = config['keysize'])
    return cacnf

def makecnf(self, args):
    """
    Write out an openssl.cnf file with the correct emailAddress field, 
    commonName field, and optional subjectAltName section
    """
    logging.debug("arguments: %r" % args)

    t = template_from_file('openssl.cnf.ca.template')

    try:
        cn = str(args.commonName)
    except:
        cn = args.keyname
    logging.debug("cn is %r" % cn)


    try:
        san = args.subjectAltName
        # we need a separate list of ip addresses vs DNS names
        subjectAltNameLines = "subjectAltName = @alt_names" + "\n\n" 
        subjectAltNameLines+= "[ alt_names ]" + "\n"
        ip=[] 
        dns=[]
        for entry in san.split(","):
            # test if this is an IP address by asking the socket module
            # NOTE: just because it's not a dotted quad doesn't mean it's not 
            # valid! "4" is a valid IP address! 
            # this is not ideal b/c openssl doesn't accept IPs that are not 
            # dotted quads. <sigh>
            # TODO: currently this doesn't match ipv6 addresses
            # see also:
            # <http://stackoverflow.com/questions/319279>
            try:
                socket.inet_aton(entry)
                ip.append(entry)
            except:
                # assume it's a hostname if it fails the socket test
                dns.append(entry)

        # The commonName MUST also be in the subjectAltName list; 
        # if it isn't specified there by the user, add it
        try: 
            socket.inet_aton(cn)
            # looks like cn is an IP address. check for it in the ip list
            for entry in ip:
                if (entry == cn): 
                    break
            else:
                ip.append(cn)
        except:
            # looks cn isn't an IP address, so assume it's a hostname. check for
            # it in the dns list. 
            for entry in dns:
                if (entry == cn): 
                    break
            else:
                dns.append(cn)

        seq=1
        for entry in dns:
            subjectAltNameLines += "DNS." + str(seq) + " = " + entry + '\n'
            seq+=1
        seq=1
        for entry in ip:
            subjectAltNameLines += "IP." + str(seq) + " = " + entry + '\n'
            seq+=1
    except AttributeError: # there is no args.subjectAltName
        subjectAltNameLines = ""
    except:
        raise

    servercnf = t.substitute(keysize = config['keysize'],
                             commonName = cn,
                             emailAddressLine = emailAddressLine,
                             subjectAltNameLines = subjectAltNameLines)

    fcnf=open("certified-keys/"+args.keyname+".openssl.cnf",'w')
    fcnf.write(servercnf)
    fcnf.close()


def signcerts(self, args):
    logging.debug("signcerts args: %r" % args)
    keyname = args.keyname

    proc = subprocess.Popen([opensslbin, 
                             "ca", 
                             "-batch", 
                             "-config", CA_CNF,
                             "-in",  "certified-keys/"+keyname+".csr", 
                             "-out", "certified-keys/"+keyname+".cert", 
                             "-days", str(SERVER_VALID_DAYS)],
                            env={"OPENSSL_CONF": CA_CNF})
    proc.wait()


def gensign(self, args):
    logging.debug("gensign args: %r" % args)
    genprivkey(self,args)
    signcerts(self,args)

def make_ovpn_zip(self, args):
    import zipfile

    # zip files list
    zfl = {'cacrt':'ca.crt.pem', 
           'dh':'dh1024.pem',
           'crt':'certified-keys/'+args.keyname+'.cert',
           'key':'certified-keys/'+args.keyname+'.key'}

    for p in zfl:
        if not (os.path.exists(zfl[p])):
            print("Path '{}' does not exist but is required, did".format(p), 
                  "you create the VPN CA and client private key and sign it?",
                  "Exiting...")
            sys.exit(1)

    zfl['ovpn'] = 'certified-keys/'+args.vpnserver+'.ovpn'
    fovpn=open(zfl['ovpn'],'w')
    fovpn.write(build_ovpn_config(self,args))
    fovpn.close()

    zovpn=zipfile.ZipFile('certified-keys/'+args.keyname+'.zip', 'w', 
                          zipfile.ZIP_STORED)

    # write each file to the same filename minus leading directories: 
    for p in zfl:
        zovpn.write(zfl[p],
                    os.path.basename(zfl[p]))
    zovpn.close()

    if args.installer or args.also_cacert:
        build_ovpn_nsis_installer(self, args)

def vpngensign(self, args):
    import zipfile
    gensign(self,args)
    make_ovpn_zip(self,args)

# TODO: do I need to pass around args all the time? can I save those to the 
#       object and then just look them up directly? 

def build_ovpn_config(self,args):
    t = template_from_file('client.ovpn.template')
    ovpn = t.substitute(keyname = args.keyname,
                             vpnserver = config['vpnserver'],
                             vpnport = config['vpnport'],
                             vpnprotocol = config['vpnprotocol'])

    return ovpn

def build_ca_nsi(self, args):
    """Build the CA part of an NSI file which makensis can use.
    The file will *not* stand on its own; it's meant to be able to be 
    incorporated in a larger NSIS installer. If you want to create an installer
    for just the CA, use build_ca_nsi() along with build_castub_nsi().
    """
    t = template_from_file('ca.nsi.template')
    cansi = t.substitute(scriptdir = scriptdir,
                         organization = config['organization'])
    return cansi

def build_castub_nsi(self, args):
    """Generate an NSI file for just installing a CA to a user's trusted root 
    store. (Must be combined with the output of build_ca_nsi().)
    """
    t = template_from_file('castub.nsi.template')
    castubnsi = t.substitute(organization = config['organization'])
    return castubnsi

def build_ovpn_nsi(self, args):
    """Generate an NSI file for installing an OpenVPN configuration. Can be 
    combined with the output of build_ca_nsi() for a single installer exe which 
    will install bother OpenVPN configuration and a certificate authority.
    """
    t = template_from_file('ovpn.nsi.template')
    ovpnnsi = t.substitute(organization = config['organization'])
    return ovpnnsi


# TODO: sanity check args.output_path
# maybe have funcs that check for existing path, valid path, writable path, etc?

def build_ovpn_nsis_installer(self, args):
    # TODO: normalize / sanity check this. NSIS is strict: must be backslashes!
    os.makedirs(os.path.abspath(os.path.expanduser(args.output_path)), 
                exist_ok=True)
    output_exe = os.path.abspath(os.path.expanduser(
        args.output_path+'/VPN-config-'+args.keyname+'.exe'))
    config_zip = os.path.abspath(os.path.expanduser(
        'certified-keys/{}.zip'.format(args.keyname)))

    # BLOCKINGTODO: handle values of ovpn_nsi_path with spaces etc. 
    #    canNOT wrap them in double quotes - NSIS won't handle those. 
    #       oh actually also things like output_exe are affected by this too
    if args.also_cacert:
        # this means that the user supplied the --installer-with-ca argument
        # we abspath() it, because makensis requires absolute paths.
        # this also ensures backslash path separators, b/c nsis can't handle 
        # forward slash.
        # TODO: verify the path of args.also_cacert in argparser so it fails 
        # immediately if it's bad
        also_cacert_path = os.path.abspath(os.path.expanduser(args.also_cacert))
        nsisargs=[makensisexe,
                  r'/DOUTPUT_EXE={}'.format(output_exe),
                  r'/DCONFIG_CACRT={}'.format(also_cacert_path),
                  r'/DCONFIG_ZIP={}'.format(config_zip),
                  r'{}'.format(ovpn_nsi_path),
                  r'{}'.format(ca_nsi_path)]
        fcnf=open(ca_nsi_path,'w')
        fcnf.write(build_ca_nsi(self, args))
        fcnf.close()
        fcnf=open(ovpn_nsi_path,'w')
        fcnf.write(build_ovpn_nsi(self, args))
        fcnf.close()
    else:
        # the user did not supply the --installer-with-ca argument
        # omit /DCONFIG_CACRT and the canh_path nsi file arguments
        nsisargs=[makensisexe,
                  r'/DOUTPUT_EXE={}'.format(output_exe),
                  r'/DCONFIG_ZIP={}'.format(config_zip),
                  r'{}'.format(ovpn_nsi_path)]
        fcnf=open(ovpn_nsi_path,'w')
        fcnf.write(build_ovpn_nsi(self, args))
        fcnf.close()

    logging.debug("Calling makensis.exe...")
    logging.debug(nsisargs)
    subprocess.check_call(nsisargs)

# TODO: this isn't exposted in argparse so.
def build_ca_nsis_installer(self, args):
    output_exe = args.output_path + '/security-certificate.exe'
    output_exe = os.path.abspath(os.path.expanduser(output_exe))
                                    
    cacert_path = os.path.abspath(os.path.expanduser(args.cacert))

    nsisargs=[makensisexe,
              r'/DOUTPUT_EXE="{}"'.format(output_exe),
              r'/DCONFIG_CACRT="{}"'.format(cacert_path),
              r'"{}"'.format(castub_nsi_path),
              r'"{}"'.format(ca_nsi_path)]

    fcnf=open(ca_nsi_path,'w')
    fcnf.write(build_ca_nsi(self, args))
    fcnf.close()
    fcnf=open(castub_nsi_path,'w')
    fcnf.write(build_castub_nsi(self, args))
    fcnf.close()

    subprocess.check_call(nsisargs)


def examinecsr(self, args):
    possible_csrs =  [args.csrfile, args.csrfile+".csr", 
                      "certified-keys/"+args.csrfile, 
                      "certified-keys/"+args.csrfile+".csr"]
    for p in possible_csrs:
        if os.path.exists(p):
            csrfile=p
            break
    else:
        print("No such CSR file '" + args.csrfile + "', exiting...")
        sys.exit(1)
    proc = subprocess.Popen([opensslbin, "req", "-in", csrfile, "-noout", 
                             "-text"],
                            env={"OPENSSL_CONF": CA_CNF})
    proc.wait()

def dmisc(self, args):
    if args.action == 'pwd':
        print(os.getcwd())
    elif args.action == 'scriptdir':
        print(scriptdir)
    else:
        print("Action "+args.action+" not defined.")


def main(*args):
    global minipki
    minipki=MINIPKI()
    global opensslbin
    if (os.name == 'nt'):
        inpath=which("openssl.exe")
        if (inpath):
            opensslbin=inpath
        else:
            # check some known locations on Windows
            for path in [r"C:\Program Files\GnuWin32\bin\openssl.exe",
                         r"C:\Program Files (x86)\GnuWin32\bin\openssl.exe",
                         r"C:\Program Files\OpenVPN\bin\openssl.exe",
                         r"C:\Program Files (x86)\OpenVPN\bin\openssl.exe",
                         r"C:\git\bin\openssl.exe"]:
                if (is_exe(path)):
                    opensslbin=path
                    break
            else:
                # if after all that we have nothing, exit
                raise Exception("Can't find OpenSSL binary.")

    elif (os.name == 'posix'):
        # for POSIX systems we're just going to assume that openssl is in the 
        # path and $EDITOR is an existing env var. 
        inpath=which("openssl")
        if (inpath):
            opensslbin=inpath
        else:
            print("Can't find OpenSSL binary. Exiting...")
            sys.exit(1)

    h= 'Perform basic tasks for a mini-PKI'
    argparser = argparse.ArgumentParser(description=h)
    subparsers = argparser.add_subparsers()
    
    h="Generate an openssl.cnf file for a server"
    subparser_makecnf = subparsers.add_parser('makecnf', help=h)

    h =  'Supply a keyname, such as myserver or myserver.sub.domain.tld. '
    h += 'By default, this also specifies a hostname'
    subparser_makecnf.add_argument('keyname', type=str, action='store', help=h)

    h = 'Specify a hostname rather than use the keyname to use in the config '
    h+= 'file.'
    subparser_makecnf.add_argument('--commonName', action='store', help=h)


    h = 'A list of subjectAltName entries, separated by commas, such as '
    h+= 'myserver,myserver.domain.tld,10.10.10.10 .'
    subparser_makecnf.add_argument('--subjectAltName',   action='store', help=h)

    subparser_makecnf.set_defaults(func=makecnf)

    subparser_examinecsr = subparsers.add_parser('examinecsr', 
                                                 help="Examine an existing CSR")
    subparser_examinecsr.add_argument('csrfile', action='store', 
                                      help='Supply the path to a .csr file')
    subparser_examinecsr.set_defaults(func=examinecsr)

    h='Generate a private key & CSR for a server')
    subparser_genkey = subparsers.add_parser('genkey', help=h)


    h = 'Supply a keyname, such as myserver or myserver.sub.domain.tld. '
    h+= 'The filenames for the cert, CSR, etc are based on this name. This '
    h+= 'subcommand also looks for an openssl configuration file named '
    h+= 'keyname.openssl.cnf; if it does not find one, it will generate '
    h+= 'one for you.'
    subparser_genkey.add_argument('keyname', type=str, action='store', help=h)

    h='Specify a hostname rather than use the keyname to use in the config '
    h+='file'.
    subparser_genkey.add_argument('--commonName', action='store', help=h)

    h ='A list of subjectAltName entries, separated by commas, such as '
    h+='myserver,myserver.domain.tld,10.10.10.10 .'
    subparser_genkey.add_argument('--subjectAltName',   action='store', help=h)

    h ='An existing openssl.cnf file. Useful if all of your server certs can '
    h+='use the same file because the commonName is optional '
    h+='(as is the case with my OpenVPN setup).'
    subparser_genkey.add_argument('--cnf', action='store', help=h)

    subparser_genkey.set_defaults(func=genprivkey)
    
    h='Sign a CSR with an existing CA key'
    subparser_sign = subparsers.add_parser('sign', help=h)

    h ='Supply a keyname, such as myserver or myserver.sub.domain.tld. '
    h+='The filenames for the cert, CSR, etc are based on this name.'
    subparser_sign.add_argument('keyname', type=str, action='store', help=h)
    subparser_sign.set_defaults(func=signcerts)

    h='Both generate and sign in one step'
    subparser_gensign = subparsers.add_parser('gensign', help=h)

    h ='Supply a keyname, such as myserver or myserver.sub.domain.tld. The '
    h+='filenames for the cert, CSR, etc are based on this name. This '
    h+='subcommand also looks for an openssl configuration file named '
    h+='keyname.openssl.cnf; if it does not find one, it will generate one for '
    h+='you.'
    subparser_gensign.add_argument('keyname', type=str, action='store', help=h)

    h='Specify a hostname rather than use the keyname to use in the config '
    h+='file.'
    subparser_gensign.add_argument('--commonName', action='store', help=h)

    h='A list of subjectAltName entries, separated by commas, such as '
    h+='myserver,myserver.domain.tld,10.10.10.10 .'
    subparser_gensign.add_argument('--subjectAltName',   action='store', help=h)

    h='An existing openssl.cnf file. Useful if all of your server certs can '
    h+='use the same file because the commonName is optional '
    h+='(as is the case with my OpenVPN setup).'
    subparser_gensign.add_argument('--cnf', action='store', help=h)

    subparser_gensign.set_defaults(func=gensign)

    h='Initialize a Certificate Authority in this directory'
    subparser_initca = subparsers.add_parser('initca', help=h)

    h='REQUIRED. Provide a commonName for your new CA.'
    subparser_initca.add_argument('--ca_commonName', '--commonName', 
                                  dest='ca_commonName',
                                  action='store', required=True, 
                                  help=h)

    h='Recommended. Provide an organization name to be included on the CA '
    h+='certificate and any subsequent server certificates.'
    subparser_initca.add_argument('--organizationName', action='store', help=h)

    h='Recommended. Provide an email address to be included on the CA '
    h+='certificate and any subsequent server certificates.'
    subparser_initca.add_argument('--emailAddress', action='store', help=h)

    h='Provide a country name to be included on the CA certificate and any '
    h+='subsequent server certificates.'
    subparser_initca.add_argument('--countryName', action='store', help=h)

    h='Provide a state or province name to be included on the CA certificate '
    h+='and any subsequent server certificates.'
    subparser_initca.add_argument('--stateOrProvinceName', action='store', 
                                  help=h)

    h='Provide a locality name to be included on the CA certificate and any '
    h+='subsequent server certificates.'
    subparser_initca.add_argument('--localityName', action='store', help=h)

    h='THIS OPTION WILL DELETE ALL FILES IN THE CURRENT DIRECTORY. '
    h+='It is really intended just for debugging.'
    subparser_initca.add_argument('--purge', action='store_true', help=h)

    subparser_initca.set_defaults(func=initca)

    h='Create a vpn configuration from an existing signed private key, and zip '
    h+='them all up.'
    subparser_vpnconfig = subparsers.add_parser('vpnconfig', help=h)

    h='Supply a keyname, such as jsmith. The filenames for the cert, CSR, etc '
    h+='are based on this name.'
    subparser_vpnconfig.add_argument('keyname', type=str, action='store', 
                                     help=h)

    h='Supply a hostname for the VPN server. Required.'
    subparser_vpnconfig.add_argument('--vpnserver', action='store', 
                                     required=True, help=h)

    h='Supply a port for the VPN server. Default is 1194.'
    subparser_vpnconfig.add_argument('--vpnport', action='store', type=int, 
                                     default=1194, 
                                     help=h)

    h='Build an installer .exe for the OpenVPN configuration after generating '
    h+='it. See the readme file for more information on this option. ' 
    subparser_vpnconfig.add_argument('--installer', action='store_true', help=h)

    h='(Implies --installer.) '
    h+='Build an installer that includes BOTH the OpenVPN configuration AND a '
    h+='root CA that is installed to a user\'s trusted CAs. '
    h+='By default assumes that your VPN CA is the same as the trusted root '
    h+='CA, but you can specify an optional "cafile" argument if '
    h+='you have a separate PKI for browser certs and VPN certs.'
    subparser_vpnconfig.add_argument('--installer-with-ca', nargs='?', 
                                     type=str, const='ca.crt.pem',
                                     default=False, dest='also_cacert', 
                                     metavar='CACRT', help=h)

    subparser_vpnconfig.set_defaults(func=make_ovpn_zip)

    h='Specify the folder for the installer built by --installer or '
    h+='--installer-with-ca. Default is your home directory.'
    subparser_vpnconfig.add_argument('--installer-output', type=str, 
                                     dest='output_path', 
                                     default='~/', help=h)

    # TODO: this is really not the ideal way to handle this
    h='Specify the organization name, used for the installer in things like the '
    h+='add/remove programs dialog, etc. REQUIRED.'
    subparser_vpnconfig.add_argument('--organization', type=str, required=True, 
                                     help=h)



    h='Generate a VPN private key, sign it, create a VPN configuration from it, '
    h+='and zip them all up.'
    subparser_vpngensign = subparsers.add_parser('vpngensign', help=h)

    h='Supply a keyname, such as jsmith. The filenames for the cert, CSR, etc '
    h+='are based on this name.'
    subparser_vpngensign.add_argument('keyname', type=str, action='store', 
                                      help=h)

    h='Supply a hostname for the VPN server. Required.'
    subparser_vpngensign.add_argument('--vpnserver', action='store', 
                                      required=True, 
                                      help=h)

    h='Supply a port for the VPN server. Default is 1194.'
    subparser_vpngensign.add_argument('--vpnport', action='store', type=int, 
                                      default=1194, help=h)

    # TODO: add this argument for the non-vpn gensign subcommand
    h='Build an installer .exe for the OpenVPN configuration after generating '
    h+='it. See the readme file for more information on this option. ' 
    subparser_vpngensign.add_argument('--installer', action='store_true', 
                                      help=h)

    # TODO: not sure this help is really clear. 
    h='(Implies --installer.) '
    h+='Build an installer that includes BOTH the OpenVPN configuration AND a '
    h+='root CA that is installed to a user\'s trusted CAs. '
    h+='By default assumes that your VPN CA is the same as the '
    h+='trusted root CA, but you can specify an optional "cafile" argument if '
    h+='you have a separate PKI for browser certs and VPN certs.'
    # notes to self: nargs=? means if it's present with a positional argument 
    # after, the posarg is used; if no posarg, const is used; if not present at
    # all, default is used. the dest setting means that's how you access the 
    # stored value, e.g. dest.cacrt will contain the posarg or ca.crt.pem or
    # False depending on how the user chooses. metavar is simply what is 
    # displayed when you run --help.
    subparser_vpngensign.add_argument('--installer-with-ca', nargs='?', 
                                      type=str, const='ca.crt.pem',
                                      default=False, dest='also_cacert', 
                                      metavar='CACRT', help=h)

    h='Specify the folder for the installer built by --installer or '
    h+='--installer-with-ca. Default is your home directory.'
    subparser_vpngensign.add_argument('--installer-output', type=str, 
                                      dest='output_path', default='~/', help=h)

    # TODO: this is really not the ideal way to handle this
    h='Specify the organization name, used for the installer in things like '
    h+='the add/remove programs dialog, etc. REQUIRED.'
    subparser_vpngensign.add_argument('--organization', type=str, 
                                      required=True, help=h)

    h='An existing openssl.cnf file. Useful if all of your certs can use the '
    h+='same file because the commonName is optional (as is the case with my '
    h+='OpenVPN setup).'
    subparser_vpngensign.add_argument('--cnf', action='store', help=h)

    subparser_vpngensign.set_defaults(func=vpngensign)

    # This is just for developing shit
    if MINIPKI_DEBUG:
        subparser_debug = subparsers.add_parser('debug', 
                                                help='Debugging options...')
        subparser_debug.add_argument('action', type=str, action='store')
        subparser_debug.set_defaults(func=dmisc)

    parsed = argparser.parse_args()
    parsed.func(parsed)

if __name__ == '__main__':
    sys.exit(main(*sys.argv))


