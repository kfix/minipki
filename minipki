#!/Usr/bin/env python3
# -*- mode: python -*-

# minipki
# Author: Micah R Ledbetter
# Acknowledgements: 
# - http://sial.org/howto/openssl/ca/
# - http://www.openssl.org/docs/apps/ca.html

import sys
import os
import shutil
import argparse
import logging
import subprocess
import socket
import re

MINIPKI_DEBUG = False

#keysize=512 #this is for testing purposes only - weak keys, but fast generation
keysize=4096 #I prefer large keys like this. You might instead prefer 1024 or 2048.

# 7300 is a few days short of 20 years and is the longest that openssl will accept
CA_VALID_DAYS = 7300
SERVER_VALID_DAYS = 7300

CA_CNF = "ca.openssl.cnf"

makensisexe=os.path.normpath(r"C:\Program Files (x86)\NSIS\makensis.exe")

#
#
# You should never have to change anything below this line
#
#

scriptdir = os.path.dirname(os.path.realpath(__file__))

ovpn_nsi_path   = os.path.abspath(os.getenv("TEMP") + '/openvpn-config.nsi')
ca_nsi_path     = os.path.abspath(os.getenv("TEMP") + '/ca.nsi')
castub_nsi_path = os.path.abspath(os.getenv("TEMP") + '/castub.nsi')

if MINIPKI_DEBUG: 
    logging.basicConfig(level=logging.DEBUG) 

def is_exe(fpath):
    return os.path.exists(fpath) and os.access(fpath, os.X_OK)

def is_existing_file(fpath):
    return os.path.exists(fpath)

def which(program):
    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file
    return None

class MINIPKI:

    def initca(self, args):
        if args.purge:
            for p in os.listdir("."): 
                if os.path.isfile(p) or os.path.islink(p): #os.unlink() handles both cases
                    os.unlink(p)
                elif os.path.isdir(p):
                    shutil.rmtree(p)
        else: 
            for p in ["serial.txt", "index.txt", "private", "newcerts", "certified-keys", CA_CNF]:
                if (os.path.exists(p)):
                    print("Path '" + p + "' exists, exiting...")
                    sys.exit(1)

        fcnf=open(CA_CNF,'w')
        fcnf.write(MINIPKI.build_ca_cnf(self,args))
        fcnf.close()

        fserial=open("serial.txt","w")
        fserial.write("01")
        fserial.close()
        open("index.txt","w").close() #create an empty file
        os.mkdir("private",0o700)
        os.mkdir("newcerts",0o700)
        os.mkdir("certified-keys",0o700)

        proc = subprocess.Popen([opensslbin, 
                                 "req", #request a new key
                                 "-config", CA_CNF,

                                 # don't create an encrypted key (& don't prompt 
                                 # for enc password): 
                                 "-nodes",  

                                 # put out a self-signed cert instead of a csr; 
                                 # required for a CA
                                 "-x509", 
                                 "-days", str(CA_VALID_DAYS),

                                 #will output to stdout otherwise, which we don't want
                                 "-out", "ca.crt.pem", 


                                 #create an RSA key store it where cnf says
                                 "-newkey", "rsa:"+str(keysize)], 
                                env={"OPENSSL_CONF": CA_CNF})
        proc.wait()

    def genprivkey(self, args):
        keyname=args.keyname
        logging.debug("genprivkey args: %r" % args)
        if args.cnf: 
            if not (os.path.exists(args.cnf)):
                print("Server configuration file specified on command line as",
                      "{}, but file does not exist. Exiting...".format(args.cnf))
                sys.exit(1)
            servercnf=args.cnf
        else:
            servercnf="certified-keys/"+keyname+".openssl.cnf"
            if not (os.path.exists(servercnf)):
                logging.debug("genprivkey: openssl configuration file not present, generating...")
                MINIPKI.makecnf(self,args)

        proc = subprocess.Popen([opensslbin, "genrsa", "-out", 
                                 "certified-keys/"+keyname+".key", str(keysize)],
                                env={"OPENSSL_CONF": servercnf})
        proc.wait()

        proc = subprocess.Popen([opensslbin, 
                                 "req", 
                                 "-new", 
                                 "-nodes",
                                 "-config", servercnf, 
                                 "-key", "certified-keys/"+keyname+".key", 
                                 "-out", "certified-keys/"+keyname+".csr"],
                                env={"OPENSSL_CONF": servercnf})
        proc.wait()

    def build_ca_cnf(self, args):
        # chunk1 is the stuff before the user settings
        # then come a few user-customizable things
        # then comes chunk2, the bulk of the file

        cacnf ="\n"
        cacnf+="# openssl.cnf.ca\n"
        cacnf+="# Via minipki\n"
        cacnf+="\n"
        cacnf+="HOME                    = .\n"
        cacnf+="RANDFILE                = $ENV::HOME/.rnd\n"
        cacnf+="\n"
        cacnf+="[ root_ca_distinguished_name ]\n"

        # this is checked by argparse so we know it exists
        cacnf+= "commonName = " + args.ca_commonName + "\n"
        if args.emailAddress:
            cacnf += "emailAddress = " + args.emailAddress + "\n"
        if args.countryName:
            cacnf += "countryName = " + args.countryName + "\n"
        if args.stateOrProvinceName:
            cacnf += "stateOrProvinceName = " + args.stateOrProvinceName + "\n"
        if args.localityName:
            cacnf += "localityName = " + args.localityName + "\n"
        if args.organizationName:
            cacnf += "organizationName = " + args.organizationName + "\n"

        cacnf+="\n"
        cacnf+="[ ca ]\n"
        cacnf+="default_ca      = CA_default\n"
        cacnf+="\n"
        cacnf+="[ CA_default ]\n"
        cacnf+="dir             = .\n"
        cacnf+="#certs           = $dir/certs\n"
        cacnf+="new_certs_dir   = $dir/newcerts\n"
        cacnf+="crl_dir         = $dir/crl\n"
        cacnf+="database        = $dir/index.txt\n"
        cacnf+="\n"
        cacnf+="certificate     = $dir/ca.crt.pem\n"
        cacnf+="serial          = $dir/serial.txt\n"
        cacnf+="crl             = $dir/ca.crl.pem\n"
        cacnf+="private_key     = $dir/private/ca.key.pem\n"
        cacnf+="RANDFILE        = $dir/private/.rand\n"
        cacnf+="x509_extensions = usr_cert\n"
        cacnf+="copy_extensions	= copy\n"
        cacnf+="unique_subject  = no\n"
        cacnf+="name_opt        = ca_default\n"
        cacnf+="cert_opt        = ca_default\n"
        cacnf+="default_crl_days= 30\n"
        cacnf+="default_days    = 365\n"
        cacnf+="default_md      = sha1\n"
        cacnf+="preserve        = no\n"
        cacnf+="policy          = policy_ca\n"
        cacnf+="\n"
        cacnf+="[ policy_ca ]\n"
        cacnf+="countryName             = optional\n"
        cacnf+="stateOrProvinceName     = optional\n"
        cacnf+="organizationName        = optional\n"
        cacnf+="organizationalUnitName  = optional\n"
        cacnf+="commonName              = supplied\n"
        cacnf+="emailAddress            = optional\n"
        cacnf+="\n"
        cacnf+="[ policy_anything ]\n"
        cacnf+="countryName             = optional\n"
        cacnf+="stateOrProvinceName     = optional\n"
        cacnf+="localityName            = optional\n"
        cacnf+="organizationName        = optional\n"
        cacnf+="organizationalUnitName  = optional\n"
        cacnf+="commonName              = supplied\n"
        cacnf+="emailAddress            = optional\n"
        cacnf+="\n"
        cacnf+="[ req ]\n"
        cacnf+="default_bits            = 4096\n"
        cacnf+="default_keyfile         = ./private/ca.key.pem\n"
        cacnf+="default_md              = sha1\n"
        cacnf+="prompt                  = no\n"
        cacnf+="distinguished_name      = root_ca_distinguished_name\n"
        cacnf+="x509_extensions         = v3_ca\n"
        cacnf+="string_mask             = nombstr\n"
        cacnf+="req_extensions          = v3_req\n"
        cacnf+="\n"
        cacnf+="[ usr_cert ]\n"
        cacnf+="basicConstraints        = CA:FALSE\n"
        cacnf+="subjectKeyIdentifier    = hash\n"
        cacnf+="authorityKeyIdentifier  = keyid,issuer:always\n"
        cacnf+="\n"
        cacnf+="[ v3_req ]\n"
        cacnf+="basicConstraints        = CA:FALSE\n"
        cacnf+="keyUsage                = nonRepudiation, digitalSignature, keyEncipherment\n"
        cacnf+="\n"
        cacnf+="[ v3_ca ]\n"
        cacnf+="subjectKeyIdentifier    = hash\n"
        cacnf+="authorityKeyIdentifier  = keyid:always,issuer:always\n"
        cacnf+="basicConstraints        = CA:true\n"
        return cacnf
    
    def build_server_cnf(self, args):
        """
        Return an openssl.cnf file with the correct emailAddress field, 
        commonName field, and optional subjectAltName section
        """
        logging.debug("arguments: %r" % args)
        # chunk1 is the part before the commonName field
        # then comes commonName
        # then emailAddress
        # then chunk2
        # then the subjectAltName stuff, if present
        chunk1= "# server openssl configuration file\n"
        chunk1+="HOME                    = .\n"
        chunk1+="RANDFILE                = $ENV::HOME/.rnd\n"
        chunk1+="\n"
        chunk1+="[ req ]\n"
        chunk1+="default_bits            = " + str(keysize) + "\n"
        chunk1+="default_md              = sha1\n"
        chunk1+="prompt                  = no\n"
        chunk1+="string_mask             = nombstr\n"
        chunk1+="\n"
        chunk1+="distinguished_name      = req_distinguished_name\n"
        chunk1+="\n"
        chunk1+="x509_extensions         = v3_req\n"
        chunk1+="req_extensions          = v3_req\n"
        chunk1+="\n"
        chunk1+="[ req_distinguished_name ]\n"
        chunk1+="countryName = US\n"
        chunk1+="stateOrProvinceName = .\n"
        chunk1+="localityName = .\n"
        chunk1+="organizationName = .\n"

        try:
            if args.commonName is str:
                cn = str(args.commonName)
            else:
                raise Exception("Should never be here lol")
        except:
            cn = args.keyname
        cnline= "commonName = " + cn + "\n"
        logging.debug("cn is %r" % cn)

        # pull email address out of CA config file - probably need to figure out a better
        # way to do this. it assumes there's only one emailAddress line.
        fcacnf=open(CA_CNF,'r')
        emailexpr = re.compile('emailAddress.*@.*')
        for line in fcacnf:
            match = emailexpr.search(line)
            if match != None:
                emailline = match.string
                break #to find only the first one
        else:
            emailline = "\n"
        fcacnf.close()

        chunk2= ""
        chunk2+="[ v3_req ]\n"
        chunk2+="nsCertType = server\n"
        chunk2+="basicConstraints = CA:FALSE\n"
        chunk2+="keyUsage = nonRepudiation, digitalSignature, keyEncipherment\n"

        try:
            san = args.subjectAltName
            # we need a separate list of ip addresses vs DNS names
            sanchunk="subjectAltName = @alt_names" + "\n\n" + "[ alt_names ]" + "\n"
            ip=[] 
            dns=[]
            for entry in san.split(","):
                # test if this is an IP address by asking the socket module
                # NOTE: just because it's not a dotted quad doesn't mean it's not valid! 
                # "4" is a valid IP address! 
                # this is not ideal b/c openssl doesn't accept IPs that are not dotted quads. <sigh>
                # TODO: currently this doesn't match ipv6 addresses
                # see also:
                # <http://stackoverflow.com/questions/319279/how-to-validate-ip-address-in-python>
                try:
                    socket.inet_aton(entry)
                    ip.append(entry)
                except:
                    # assume it's a hostname if it fails the socket test
                    dns.append(entry)

            # The commonName MUST also be in the subjectAltName list; 
            # if it isn't specified there by the user, add it
            try: 
                socket.inet_aton(cn)
                # looks like cn is an IP address. check for it in the ip list
                for entry in ip:
                    if (entry == cn): 
                        break
                else:
                    ip.append(cn)
            except:
                # looks cn isn't an IP address, so assume it's a hostname. check for it in
                # the dns list. 
                for entry in dns:
                    if (entry == cn): 
                        break
                else:
                    dns.append(cn)

            seq=1
            for entry in dns:
                sanchunk += "DNS." + str(seq) + " = " + entry + '\n'
                seq+=1
            seq=1
            for entry in ip:
                sanchunk += "IP." + str(seq) + " = " + entry + '\n'
                seq+=1
        except AttributeError: # there is no args.subjectAltName
            sanchunk="\n"
        except:
            raise

        servercnf = chunk1 + cnline + emailline + chunk2 + sanchunk
        return servercnf

    def makecnf(self, args):
        fcnf=open("certified-keys/"+args.keyname+".openssl.cnf",'w')
        fcnf.write(MINIPKI.build_server_cnf(self,args))
        fcnf.close()
        
    def signcerts(self, args):
        logging.debug("signcerts args: %r" % args)
        keyname = args.keyname

        proc = subprocess.Popen([opensslbin, 
                                 "ca", 
                                 "-batch", 
                                 "-config", CA_CNF,
                                 "-in",  "certified-keys/"+keyname+".csr", 
                                 "-out", "certified-keys/"+keyname+".cert", 
                                 "-days", str(SERVER_VALID_DAYS)],
                                env={"OPENSSL_CONF": CA_CNF})
        proc.wait()

    
    def gensign(self, args):
        logging.debug("gensign args: %r" % args)
        MINIPKI.genprivkey(self,args)
        MINIPKI.signcerts(self,args)

    def make_ovpn_zip(self, args):
        import zipfile

        # zip files list
        zfl = {'cacrt':'ca.crt.pem', 
               'dh':'dh1024.pem',
               'crt':'certified-keys/'+args.keyname+'.cert',
               'key':'certified-keys/'+args.keyname+'.key'}

        for p in zfl:
            if not (os.path.exists(zfl[p])):
                print("Path '{}' does not exist but is required, did you create".format(p), 
                      "the VPN CA and client private key and sign it? Exiting...")
                sys.exit(1)

        zfl['ovpn'] = 'certified-keys/'+args.vpnserver+'.ovpn'
        fovpn=open(zfl['ovpn'],'w')
        fovpn.write(MINIPKI.build_ovpn_config(self,args))
        fovpn.close()

        zovpn=zipfile.ZipFile('certified-keys/'+args.keyname+'.zip','w',zipfile.ZIP_STORED)
        for p in zfl:
            zovpn.write(zfl[p], #write this file
                        os.path.basename(zfl[p])) #to the same filename minus leading directories
        zovpn.close()

        if args.installer or args.also_cacert:
            MINIPKI.create_ovpn_nsis_installer(self, args)

    def vpngensign(self, args):
        import zipfile
        MINIPKI.gensign(self,args)
        MINIPKI.make_ovpn_zip(self,args)

    # TODO: standardize "build_..." vs "create_..." verbage in function names
    # TODO: standardize self.func(args) vs MINIPKI.func(self, args)
    # TODO: do I need to pass around args all the time? can I save those to the object and then
    #       just look them up directly? 

    def build_ovpn_config(self,args):
        ovpnfile =""
        ovpnfile+="client" + "\r\n"
        ovpnfile+="proto udp" + "\r\n"
        ovpnfile+="dev tap" + "\r\n"
        ovpnfile+="dh dh1024.pem" + "\r\n"
        ovpnfile+="ca ca.crt.pem" + "\r\n"
        ovpnfile+='cert ' + args.keyname+'.cert' + '\r\n'
        ovpnfile+='key ' + args.keyname+'.key' + '\r\n'
        ovpnfile+='remote ' + args.vpnserver + ' ' + str(args.vpnport) + "\r\n"
        ovpnfile+="cipher BF-CBC" + "\r\n"
        ovpnfile+="verb 2" + "\r\n"
        ovpnfile+="mute 20" + "\r\n"
        ovpnfile+="keepalive 10 120" + "\r\n"
        ovpnfile+="comp-lzo" + "\r\n"
        ovpnfile+="persist-key" + "\r\n"
        ovpnfile+="persist-tun" + "\r\n"
        ovpnfile+="float" + "\r\n"
        ovpnfile+="resolv-retry infinite" + "\r\n"
        ovpnfile+="nobind" + "\r\n"
        ovpnfile+="route-method exe" + "\r\n"
        ovpnfile+="route-delay 2" + "\r\n"
        ovpnfile+="route 192.168.55.0 255.255.255.0 192.168.59.1 3" + "\r\n"
        return ovpnfile

    def build_ca_nsi(self, args):
        """Build the CA part of an NSI file which makensis can use.
        The file will *not* stand on its own; it's meant to be able to be incorporated in a larger
        NSIS installer. If you want to create an installer for just the CA, use build_ca_nsi() along
        with build_castub_nsi().
        """
        canhnsi=''
        canhnsi+='!include "'+scriptdir+'\contrib\certificate.nsh"' +'\r\n'
        canhnsi+='!include LogicLib.nsh' +'\r\n'
        canhnsi+='' +'\r\n'
        canhnsi+='!ifndef CONFIG_CACRT' +'\r\n'
        canhnsi+='    !echo "Missing /DCONFIG_CACRT argument for makensis.exe!"' +'\r\n'
        canhnsi+='    !echo "We are assuming there is a file ca.crt in the CWD."' +'\r\n'
        canhnsi+='    !define CONFIG_CACRT "ca.crt"' +'\r\n'
        canhnsi+='!endif' +'\r\n'
        canhnsi+='' +'\r\n'
        canhnsi+='Section "Install '+args.organization+' Certificate Authority"' +'\r\n'
        canhnsi+='    File "/oname=$TEMP\ca.crt" "${CONFIG_CACRT}"' +'\r\n'
        canhnsi+='' +'\r\n'
        canhnsi+='    ; Internet Explorer' +'\r\n'
        canhnsi+='    Push "$TEMP\ca.crt"' +'\r\n'
        canhnsi+='    Call AddCertificateToStore' +'\r\n'
        canhnsi+='    Pop $0' +'\r\n'
        canhnsi+='    ${If} $0 != success' +'\r\n'
        canhnsi+='        MessageBox MB_OK "import failed: $0"' +'\r\n'
        canhnsi+='    ${EndIf}' +'\r\n'
        canhnsi+='' +'\r\n'
        canhnsi+='    ; Firefox' +'\r\n'
        canhnsi+='    ReadINIStr $1 "$APPDATA\Mozilla\Firefox\profiles.ini" "Profile0" "Path"\r\n'

        # weird NSIS idiom: if there's an error, jump 0 lines; else jump +2 lines
        canhnsi+='        IfErrors 0 +2' +'\r\n' # if errors, jump 0 lines; else jump +2 lines
        # if there was an error, we arrive here, which jumps us to the end b/c Firefox isn't installed
        # (or hasn't been run on this account)
        canhnsi+='        goto end' +'\r\n'

        canhnsi+='    !insertmacro AddFirefoxCertificate $TEMP\ca.crt $APPDATA\Mozilla\Firefox\$1' +'\r\n'
        canhnsi+='    ' +'\r\n'
        canhnsi+='    end: ' +'\r\n'
        canhnsi+='SectionEnd' +'\r\n'
        canhnsi+='' +'\r\n'
        return canhnsi

    def build_castub_nsi(self, args):
        """Generate an NSI file for just installing a CA to a user's trusted root store. 
        (Must be combined with the output of build_ca_nsi().)
        """
        cansi=''
        cansi+='!ifndef OUTPUT_EXE'+'\r\n'
        cansi+='    !define OUTPUT_EXE "'+args.organization+'-CA.exe"'+'\r\n'
        cansi+='!endif'+'\r\n'
        cansi+='Name "'+args.organization+' certificate authority installer"'+'\r\n'
        cansi+='Outfile "${OUTPUT_EXE}"'+'\r\n'
        cansi+='RequestExecutionLevel admin'+'\r\n'
        cansi+='ShowInstDetails nevershow'+'\r\n'
        return cansi

    def build_ovpn_nsi(self, args):
        """Generate an NSI file for installing an OpenVPN configuration. Can be combined with
        the output of build_ca_nsi() for a single installer exe which will install bother OpenVPN
        configuration and a certificate authority.
        """
        ovpnnsi=r''
        ovpnnsi+=r'!include LogicLib.nsh'+'\r\n'
        ovpnnsi+=r'!include x64.nsh'+'\r\n'
        ovpnnsi+=r'!include "NSISpcre.nsh"'+'\r\n'
        ovpnnsi+=r''+'\r\n'
        ovpnnsi+=r'!ifndef CONFIG_ZIP'+'\r\n'
        ovpnnsi+=r'    !echo "You did not pass a /DCONFIG_ZIP=C:\path\to\asdf.zip argument to makensis.exe!"'+'\r\n'
        ovpnnsi+=r'    !echo "We are assuming there is a file '+args.organization+'-vpn-config.zip in the CWD."'+'\r\n'
        ovpnnsi+=r'    !define CONFIG_ZIP "'+args.organization+'-vpn-config.zip"'+'\r\n'
        ovpnnsi+=r'!endif'+'\r\n'
        ovpnnsi+=r''+'\r\n'
        ovpnnsi+=r'!ifndef OUTPUT_EXE'+'\r\n'
        ovpnnsi+=r'    !define OUTPUT_EXE "'+args.organization+'-OpenVPN-config.exe"'+'\r\n'
        ovpnnsi+=r'!endif'+'\r\n'
        ovpnnsi+=r''+'\r\n'
        ovpnnsi+=r'Var /global OVPN_CONF_DIR'+'\r\n'
        ovpnnsi+=r'Var /global OVPNGUI_PATH'+'\r\n'
        ovpnnsi+=r'Var /global OVPN_DIR'+'\r\n'
        ovpnnsi+=r'Var /global UNINSTALLER_PATH'+'\r\n'
        ovpnnsi+=r'Var /global UNINSTALLER_KEY'+'\r\n'
        ovpnnsi+=r''+'\r\n'
        ovpnnsi+=r'!macro GetOvpnDir'+'\r\n'
        ovpnnsi+=r'    ;StrCpy $OVPN_DIR "C:\Program Files\OpenVPN"'+'\r\n'
        ovpnnsi+=r'    ;StrCpy $OVPN_CONF_DIR "$OVPN_DIR\config"'+'\r\n'
        ovpnnsi+=r''+'\r\n'
        ovpnnsi+=r'    ; If you do not do this, you will not see the 64 bit reg keys AGH.'+'\r\n'
        ovpnnsi+=r'    ${If} ${RunningX64}'+'\r\n'
        ovpnnsi+=r'        SetRegView 64'+'\r\n'
        ovpnnsi+=r'    ${EndIf}'+'\r\n'
        ovpnnsi+=r'    ClearErrors'+'\r\n'
        ovpnnsi+=r'    ReadRegStr $OVPN_DIR HKLM "SOFTWARE\OpenVPN" ""'+'\r\n'
        ovpnnsi+=r'    IfErrors 0 +3 ; iferrors, skip 0 lines, else, skip the next 2 lines (+3 means skip 2, cool right)'+'\r\n'
        ovpnnsi+=r'        MessageBox MB_OK "Cannot find OpenVPN installed. You must install OpenVPN first! Exiting..."'+'\r\n'
        ovpnnsi+=r'        Quit'+'\r\n'
        ovpnnsi+=r'    ReadRegStr $OVPN_CONF_DIR HKLM "SOFTWARE\OpenVPN" "config_dir"'+'\r\n'
        ovpnnsi+=r'    StrCpy $OVPNGUI_PATH "$OVPN_DIR\bin\openvpn-gui.exe"'+'\r\n'
        ovpnnsi+=r'    StrCpy $UNINSTALLER_PATH "$OVPN_CONF_DIR\uninstall-'+args.organization+'-vpn-config.exe"'+'\r\n'
        ovpnnsi+=r'    StrCpy $UNINSTALLER_KEY "Software\Microsoft\Windows\CurrentVersion\Uninstall\OpenVPN-'+args.organization+'-Config"'+'\r\n'
        ovpnnsi+=r'!macroend'+'\r\n'
        ovpnnsi+=r''+'\r\n'
        ovpnnsi+=r'Name "'+args.organization+' OpenVPN configuration installer"'+'\r\n'
        ovpnnsi+=r'Outfile "${OUTPUT_EXE}"'+'\r\n'
        ovpnnsi+=r'RequestExecutionLevel admin'+'\r\n'
        ovpnnsi+=r'ShowInstDetails show'+'\r\n'
        ovpnnsi+=r''+'\r\n'
        ovpnnsi+=r'Page components'+'\r\n'
        ovpnnsi+=r'Page instfiles'+'\r\n'
        ovpnnsi+=r''+'\r\n'
        ovpnnsi+=r'UninstPage instfiles'+'\r\n'
        ovpnnsi+=r''+'\r\n'
        ovpnnsi+=r'Section "'+args.organization+' OpenVPN user configuration"'+'\r\n'
        ovpnnsi+=r''+'\r\n'
        ovpnnsi+=r'    SetDetailsView show'+'\r\n'
        ovpnnsi+=r'    !insertmacro GetOvpnDir'+'\r\n'
        ovpnnsi+=r''+'\r\n'
        ovpnnsi+=r'    Setoutpath "$OVPN_CONF_DIR"'+'\r\n'
        ovpnnsi+=r'    File "/oname='+args.organization+'-vpn-config.zip" "${CONFIG_ZIP}"'+'\r\n'
        ovpnnsi+=r'    nsUnzip::Extract /u "$OVPN_CONF_DIR\\'+args.organization+'-vpn-config.zip" /d="$OVPN_CONF_DIR" /END'+'\r\n'
        ovpnnsi+=r''+'\r\n'
        ovpnnsi+=r'    ; create uninstall info'+'\r\n'
        ovpnnsi+=r'    WriteRegStr   HKLM $UNINSTALLER_KEY "DisplayName" "OpenVPN - '+args.organization+' Configuration"'+'\r\n'
        ovpnnsi+=r'    WriteRegStr   HKLM $UNINSTALLER_KEY "UninstallString" "$UNINSTALLER_PATH"'+'\r\n'
        ovpnnsi+=r'    WriteRegStr   HKLM $UNINSTALLER_KEY "Publisher" "'+args.organization+'"'+'\r\n'
        ovpnnsi+=r'    WriteRegStr   HKLM $UNINSTALLER_KEY "NoModify" 0x1'+'\r\n'
        ovpnnsi+=r'    WriteRegDWORD HKLM $UNINSTALLER_KEY "NoRepair" 0x1'+'\r\n'
        ovpnnsi+=r'    WriteUninstaller "$UNINSTALLER_PATH"'+'\r\n'
        ovpnnsi+=r'SectionEnd'+'\r\n'
        ovpnnsi+=r''+'\r\n'
        ovpnnsi+=r'Section "Force OpenVPN to run as admin"'+'\r\n'
        ovpnnsi+=r'    SetDetailsView show'+'\r\n'
        ovpnnsi+=r'    !insertmacro GetOvpnDir'+'\r\n'
        ovpnnsi+=r'    WriteRegStr HKLM "SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Layers" "$OVPNGUI_PATH" "RUNASADMIN"'+'\r\n'
        ovpnnsi+=r'    WriteRegStr HKCU "SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Layers" "$OVPNGUI_PATH" "RUNASADMIN"'+'\r\n'
        ovpnnsi+=r'SectionEnd'+'\r\n'
        ovpnnsi+=r''+'\r\n'
        ovpnnsi+=r'Section "Uninstall"'+'\r\n'
        ovpnnsi+=r'    SetDetailsView show'+'\r\n'
        ovpnnsi+=r'    !insertmacro GetOvpnDir'+'\r\n'
        ovpnnsi+=r'    DeleteRegValue HKLM "SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Layers" "$OVPNGUI_PATH"'+'\r\n'
        ovpnnsi+=r'    DeleteRegValue HKCU "SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Layers" "$OVPNGUI_PATH"'+'\r\n'
        ovpnnsi+=r'    DeleteRegKey HKLM $UNINSTALLER_KEY'+'\r\n'
        ovpnnsi+=r'    Delete /REBOOTOK "$OVPN_CONF_DIR\\'+args.organization+'.ovpn"'+'\r\n'
        ovpnnsi+=r'    Delete /REBOOTOK "$OVPN_CONF_DIR\\'+args.organization+'-*"'+'\r\n'
        ovpnnsi+=r'    Delete /REBOOTOK "$UNINSTALLER_PATH"'+'\r\n'
        ovpnnsi+=r'SectionEnd'+'\r\n'
        return ovpnnsi


    # TODO: sanity check args.output_path
    # maybe have funcs that check for existing path, valid path, writable path, etc?

    def create_ovpn_nsis_installer(self, args):
        # TODO: normalize / sanity check this. NSIS is strict: must be backslashes!
        os.makedirs(os.path.abspath(os.path.expanduser(args.output_path)), exist_ok=True)
        output_exe = os.path.abspath(os.path.expanduser(
            args.output_path+'/VPN-config-'+args.keyname+'.exe'))
        config_zip = os.path.abspath(os.path.expanduser(
            'certified-keys/{}.zip'.format(args.keyname)))

        # BLOCKINGTODO: handle values of ovpn_nsi_path with spaces etc. 
        #    canNOT wrap them in double quotes - NSIS won't handle those. 
        #       oh actually also things like output_exe are affected by this too
        if args.also_cacert:
            # this means that the user supplied the --installer-with-ca argument
            # we abspath() it, because makensis requires absolute paths.
            # this also ensures backslash path separators, b/c nsis can't handle forward slash.
            # TODO: verify the path of args.also_cacert in argparser so it fails 
            # immediately if it's bad
            also_cacert_path = os.path.abspath(os.path.expanduser(args.also_cacert))
            nsisargs=[makensisexe,
#            nsisargs=['"{}"'.format(makensisexe),
                      r'/DOUTPUT_EXE={}'.format(output_exe),
                      r'/DCONFIG_CACRT={}'.format(also_cacert_path),
                      r'/DCONFIG_ZIP={}'.format(config_zip),
                      r'{}'.format(ovpn_nsi_path),
                      r'{}'.format(ca_nsi_path)]
            fcnf=open(ca_nsi_path,'w')
            fcnf.write(MINIPKI.build_ca_nsi(self, args))
            fcnf.close()
            fcnf=open(ovpn_nsi_path,'w')
            fcnf.write(MINIPKI.build_ovpn_nsi(self, args))
            fcnf.close()
        else:
            # the user did not supply the --installer-with-ca argument
            # omit /DCONFIG_CACRT and the canh_path nsi file arguments
            nsisargs=[makensisexe,
                      r'/DOUTPUT_EXE={}'.format(output_exe),
                      r'/DCONFIG_ZIP={}'.format(config_zip),
                      r'{}'.format(ovpn_nsi_path)]
            fcnf=open(ovpn_nsi_path,'w')
            fcnf.write(MINIPKI.build_ovpn_nsi(self, args))
            fcnf.close()

        logging.debug("Calling makensis.exe...")
        logging.debug(nsisargs)
        subprocess.check_call(nsisargs)

    # TODO: this isn't exposted in argparse so.
    def build_ca_nsis_installer(self, args):
        output_exe = os.path.abspath(os.path.expanduser(args.output_path + '/security-certificate.exe'))
        cacert_path = os.path.abspath(os.path.expanduser(args.cacert))

        nsisargs=[makensisexe,
                  r'/DOUTPUT_EXE="{}"'.format(output_exe),
                  r'/DCONFIG_CACRT="{}"'.format(cacert_path),
                  r'"{}"'.format(castub_nsi_path),
                  r'"{}"'.format(ca_nsi_path)]

        fcnf=open(ca_nsi_path,'w')
        fcnf.write(MINIPKI.build_ca_nsi(self, args))
        fcnf.close()
        fcnf=open(castub_nsi_path,'w')
        fcnf.write(MINIPKI.build_castub_nsi(self, args))
        fcnf.close()

        subprocess.check_call(nsisargs)

    
    def examinecsr(self, args):
        possible_csrs =  [args.csrfile, args.csrfile+".csr", "certified-keys/"+args.csrfile, 
                          "certified-keys/"+args.csrfile+".csr"]
        for p in possible_csrs:
            if os.path.exists(p):
                csrfile=p
                break
        else:
            print("No such CSR file '" + args.csrfile + "', exiting...")
            sys.exit(1)
        #subprocess.check_call([opensslbin, "req", "-in", csrfile, "-noout", "-text"])
        proc = subprocess.Popen([opensslbin, "req", "-in", csrfile, "-noout", "-text"],
                                env={"OPENSSL_CONF": CA_CNF})
        proc.wait()

    def dmisc(self, args):
        if args.action == 'pwd':
            print(os.getcwd())
        elif args.action == 'scriptdir':
            print(scriptdir)
        else:
            print("Action "+args.action+" not defined.")


def main(*args):
    global minipki
    minipki=MINIPKI()
    #logging.debug("main args: " + args)
    global opensslbin
    if (os.name == 'nt'):
        inpath=which("openssl.exe")
        if (inpath):
            opensslbin=inpath
        else:
            # check some known locations on Windows
            for path in [r"C:\Program Files\GnuWin32\bin\openssl.exe",
                         r"C:\Program Files (x86)\GnuWin32\bin\openssl.exe",
                         r"C:\Program Files\OpenVPN\bin\openssl.exe",
                         r"C:\Program Files (x86)\OpenVPN\bin\openssl.exe",
                         r"C:\git\bin\openssl.exe"]:
                if (is_exe(path)):
                    opensslbin=path
                    break
            else:
                # if after all that we have nothing, exit
                print("Can't find OpenSSL binary. Try adding the location of openssl.exe to", 
                      "your PATH environment variable. Exiting...")
                sys.exit(1)

    elif (os.name == 'posix'):
        # for POSIX systems we're just going to assume that openssl is in the path and $EDITOR 
        # is an existing env var. 
        inpath=which("openssl")
        if (inpath):
            opensslbin=inpath
        else:
            print("Can't find OpenSSL binary. Exiting...")
            sys.exit(1)

    argparser = argparse.ArgumentParser(description='Perform basic tasks for a mini-PKI')
    subparsers = argparser.add_subparsers()
    
    subparser_makecnf = subparsers.add_parser('makecnf', help="Generate an openssl.cnf file for a server")

    h =  'Supply a keyname, such as myserver or myserver.sub.domain.tld. '
    h += 'By default, this also specifies a hostname'
    subparser_makecnf.add_argument('keyname', type=str, action='store', help=h)

    h = 'Specify a hostname rather than use the keyname to use in the config file.'
    subparser_makecnf.add_argument('--commonName', action='store', help=h)


    h = 'A list of subjectAltName entries, separated by commas, such as '
    h+= 'myserver,myserver.domain.tld,10.10.10.10 .'
    subparser_makecnf.add_argument('--subjectAltName',   action='store', help=h)

    subparser_makecnf.set_defaults(func=minipki.makecnf)

    subparser_examinecsr = subparsers.add_parser('examinecsr', help="Examine an existing CSR")
    subparser_examinecsr.add_argument('csrfile', action='store', 
                                      help='Supply the path to a .csr file')
    subparser_examinecsr.set_defaults(func=minipki.examinecsr)

    subparser_genkey = subparsers.add_parser('genkey', 
                                             help='Generate a private key & CSR for a server')


    h = 'Supply a keyname, such as myserver or myserver.sub.domain.tld. '
    h+= 'The filenames for the cert, CSR, etc are based on this name. This '
    h+= 'subcommand also looks for an openssl configuration '
    h+= 'file named keyname.openssl.cnf; if it does not find one, it will generate one for you.'
    subparser_genkey.add_argument('keyname', type=str, action='store', help=h)

    h='Specify a hostname rather than use the keyname to use in the config file.'
    subparser_genkey.add_argument('--commonName', action='store', help=h)

    h ='A list of subjectAltName entries, separated by commas, such as '
    h+='myserver,myserver.domain.tld,10.10.10.10 .'
    subparser_genkey.add_argument('--subjectAltName',   action='store', help=h)

    h ='An existing openssl.cnf file. Useful if all of your server certs can '
    h+='use the same file because the commonName is optional '
    h+='(as is the case with my OpenVPN setup).'
    subparser_genkey.add_argument('--cnf', action='store', help=h)

    subparser_genkey.set_defaults(func=minipki.genprivkey)
    
    subparser_sign = subparsers.add_parser('sign', help='Sign a CSR with an existing CA key')

    h ='Supply a keyname, such as myserver or myserver.sub.domain.tld. '
    h+='The filenames for the cert, CSR, etc are based on this name.'
    subparser_sign.add_argument('keyname', type=str, action='store', help=h)
    subparser_sign.set_defaults(func=minipki.signcerts)

    subparser_gensign = subparsers.add_parser('gensign', help='Both generate and sign in one step')

    h ='Supply a keyname, such as myserver or myserver.sub.domain.tld. The '
    h+='filenames for the cert, CSR, etc are based on this name. This '
    h+='subcommand also looks for an openssl configuration file named '
    h+='keyname.openssl.cnf; if it does not find one, it will generate one for you.'
    subparser_gensign.add_argument('keyname', type=str, action='store', help=h)

    h='Specify a hostname rather than use the keyname to use in the config file.'
    subparser_gensign.add_argument('--commonName', action='store', help=h)

    h='A list of subjectAltName entries, separated by commas, such as '
    h+='myserver,myserver.domain.tld,10.10.10.10 .'
    subparser_gensign.add_argument('--subjectAltName',   action='store', help=h)

    h='An existing openssl.cnf file. Useful if all of your server certs can '
    h+='use the same file because the commonName is optional '
    h+='(as is the case with my OpenVPN setup).'
    subparser_gensign.add_argument('--cnf', action='store', help=h)

    subparser_gensign.set_defaults(func=minipki.gensign)

    h='Initialize a Certificate Authority in this directory'
    subparser_initca = subparsers.add_parser('initca', help=h)

    subparser_initca.add_argument('--ca_commonName', '--commonName', dest='ca_commonName',
                                  action='store', required=True, 
                                  help='REQUIRED. Provide a commonName for your new CA.')

    h='Recommended. Provide an organization name to be included on the CA certificate and any '
    h+='subsequent server certificates.'
    subparser_initca.add_argument('--organizationName', action='store', help=h)

    h='Recommended. Provide an email address to be included on the CA '
    h+='certificate and any subsequent server certificates.'
    subparser_initca.add_argument('--emailAddress', action='store', help=h)

    h='Provide a country name to be included on the CA certificate and any '
    h+='subsequent server certificates.'
    subparser_initca.add_argument('--countryName', action='store', help=h)

    h='Provide a state or province name to be included on the CA certificate '
    h+='and any subsequent server certificates.'
    subparser_initca.add_argument('--stateOrProvinceName', action='store', help=h)

    h='Provide a locality name to be included on the CA certificate and any '
    h+='subsequent server certificates.'
    subparser_initca.add_argument('--localityName', action='store', help=h)

    h='THIS OPTION WILL DELETE ALL FILES IN THE CURRENT DIRECTORY. '
    h+='It is really intended just for debugging.'
    subparser_initca.add_argument('--purge', action='store_true', help=h)

    subparser_initca.set_defaults(func=minipki.initca)

    h='Create a vpn configuration from an existing signed private key, and zip them all up.'
    subparser_vpnconfig = subparsers.add_parser('vpnconfig', help=h)

    h='Supply a keyname, such as jsmith. The filenames for the cert, CSR, etc '
    h+='are based on this name.'
    subparser_vpnconfig.add_argument('keyname', type=str, action='store', help=h)

    h='Supply a hostname for the VPN server. Required.'
    subparser_vpnconfig.add_argument('--vpnserver', action='store', required=True, help=h)

    subparser_vpnconfig.add_argument('--vpnport', action='store', type=int, default=1194, 
                                     help='Supply a port for the VPN server. Default is 1194.')

    h='Build an installer .exe for the OpenVPN configuration after generating it. '
    h+='See the readme file for more information on this option. ' 
    subparser_vpnconfig.add_argument('--installer', action='store_true', help=h)

    h='(Implies --installer.) '
    h+='Build an installer that includes BOTH the OpenVPN configuration AND a root CA that '
    h+='is installed to a user\'s trusted CAs. '
    h+='By default assumes that your VPN CA is the '
    h+='same as the trusted root CA, but you can specify an optional "cafile" argument if '
    h+='you have a separate PKI for browser certs and VPN certs.'
    subparser_vpnconfig.add_argument('--installer-with-ca', nargs='?', type=str, const='ca.crt.pem',
                                     default=False, dest='also_cacert', metavar='CACRT', help=h)

    subparser_vpnconfig.set_defaults(func=minipki.make_ovpn_zip)

    h='Specify the folder for the installer built by --installer or --installer-with-ca. '
    h+='Default is your home directory.'
    subparser_vpnconfig.add_argument('--installer-output', type=str, dest='output_path', 
                                     default='~/', help=h)

    # TODO: this is really not the ideal way to handle this
    h='Specify the organization name, used for the installer in things like the add/remove programs '
    h+='dialog, etc. REQUIRED.'
    subparser_vpnconfig.add_argument('--organization', type=str, required=True, help=h)



    h='Generate a VPN private key, sign it, create a VPN configuration from it, and zip them all up.'
    subparser_vpngensign = subparsers.add_parser('vpngensign', help=h)

    h='Supply a keyname, such as jsmith. The filenames for the cert, CSR, etc '
    h+='are based on this name.'
    subparser_vpngensign.add_argument('keyname', type=str, action='store', help=h)

    subparser_vpngensign.add_argument('--vpnserver', action='store', required=True, 
                                      help='Supply a hostname for the VPN server. Required.')

    subparser_vpngensign.add_argument('--vpnport', action='store', type=int, default=1194, 
                                      help='Supply a port for the VPN server. Default is 1194.')

    # TODO: add this argument for the non-vpn gensign subcommand
    h='Build an installer .exe for the OpenVPN configuration after generating it. '
    h+='See the readme file for more information on this option. ' 
    subparser_vpngensign.add_argument('--installer', action='store_true', help=h)

    # TODO: not sure this help is really clear. 
    h='(Implies --installer.) '
    h+='Build an installer that includes BOTH the OpenVPN configuration AND a root CA that '
    h+='is installed to a user\'s trusted CAs. '
    h+='By default assumes that your VPN CA is the '
    h+='same as the trusted root CA, but you can specify an optional "cafile" argument if '
    h+='you have a separate PKI for browser certs and VPN certs.'
    # notes to self: nargs=? means if it's present with a positional argument 
    # after, the posarg is used; if no posarg, const is used; if not present at
    # all, default is used. the dest setting means that's how you access the 
    # stored value, e.g. dest.cacrt will contain the posarg or ca.crt.pem or
    # False depending on how the user chooses. metavar is simply what is 
    # displayed when you run --help.
    subparser_vpngensign.add_argument('--installer-with-ca', nargs='?', type=str, const='ca.crt.pem',
                                      default=False, dest='also_cacert', metavar='CACRT', help=h)

    h='Specify the folder for the installer built by --installer or --installer-with-ca. '
    h+='Default is your home directory.'
    subparser_vpngensign.add_argument('--installer-output', type=str, dest='output_path', 
                                      default='~/', help=h)

    # TODO: this is really not the ideal way to handle this
    h='Specify the organization name, used for the installer in things like the add/remove programs '
    h+='dialog, etc. REQUIRED.'
    subparser_vpngensign.add_argument('--organization', type=str, required=True, help=h)

    h='An existing openssl.cnf file. Useful if all of your certs can use the same file because the '
    h+='commonName is optional (as is the case with my OpenVPN setup).'
    subparser_vpngensign.add_argument('--cnf', action='store', help=h)

    subparser_vpngensign.set_defaults(func=minipki.vpngensign)

    # This is just for developing shit
    if MINIPKI_DEBUG:
        subparser_debug = subparsers.add_parser('debug', help='Debugging options...')
        subparser_debug.add_argument('action', type=str, action='store')
        subparser_debug.set_defaults(func=minipki.dmisc)

    parsed = argparser.parse_args()
    parsed.func(parsed)

if __name__ == '__main__':
    sys.exit(main(*sys.argv))


